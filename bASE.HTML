<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Radar Control Test – Standalone v3</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 UMD + ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel to run JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-slate-100">
    <div id="app" class="p-4"></div>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      // --- Utility helpers --------------------------------------------------------
      const deg2rad = (d) => (d * Math.PI) / 180;
      const rad2deg = (r) => (r * 180) / Math.PI;
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const uid = () => Math.random().toString(36).slice(2, 9).toUpperCase();

      // NM <-> px scaling (cosmetic)
      const NM_TO_PX = 12;
      const TICK_MS = 120; // tick duration
      const HEADING_DEG_PER_SEC = 15; // progressive turn rate
      const FL_RATE_PER_SEC = 3.3; // FL units per second (progressive altitude change)

      // Airways / waypoints --------------------------------------------------------
      const WAYPOINTS = {
        A: { x: 10, y: 35 },
        B: { x: 38, y: 35 },
        C: { x: 66, y: 35 },
        D: { x: 38, y: 15 },
        E: { x: 56, y: 8 },
        F: { x: 20, y: 60 },
        G: { x: 58, y: 52 },
        H: { x: 76, y: 60 },
        I: { x: 6, y: 24 },
        J: { x: 38, y: 4 },
        K: { x: 20, y: 12 },
        L: { x: 80, y: 35 },
      };

      const AIRWAYS = [
        ["A","B"], ["B","C"], ["B","D"], ["D","J"], ["B","G"],
        ["G","H"], ["A","F"], ["A","I"], ["A","K"], ["C","L"],
      ];

      // Entry lanes from edges into sector (from -> towards)
      const ENTRY_LANES = [
        { from: "A", to: "B" }, { from: "C", to: "B" }, { from: "D", to: "B" },
        { from: "J", to: "D" }, { from: "F", to: "A" }, { from: "H", to: "G" },
        { from: "I", to: "A" }, { from: "K", to: "A" }, { from: "L", to: "C" },
      ];

      const CORRIDOR_HALF_WIDTH_NM = 1.0;

      // Geometry ------------------------------------------------------------------
      function distNM(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        return Math.hypot(dx, dy);
      }
      function pointLineDistanceNM(p, a, b) {
        const APx = p.x - a.x, APy = p.y - a.y;
        const ABx = b.x - a.x, ABy = b.y - a.y;
        const ab2 = ABx * ABx + ABy * ABy || 1;
        const t = clamp((APx * ABx + APy * ABy) / ab2, 0, 1);
        const x = a.x + ABx * t, y = a.y + ABy * t;
        return Math.hypot(p.x - x, p.y - y);
      }
      function headingToVector(hdg) {
        const r = deg2rad(90 - hdg);
        return { x: Math.cos(r), y: -Math.sin(r) };
      }
      function vectorToHeading(dx, dy) {
        const r = Math.atan2(-dy, dx);
        let hdg = (90 - rad2deg(r)) % 360;
        if (hdg < 0) hdg += 360;
        return Math.round(hdg);
      }

      // ATIS ----------------------------------------------------------------------
      const POINT_KEYS = Object.keys(WAYPOINTS);
      const FLIGHT_PREFIX = ["APR","EVD","QFA","DLH","BAW","AFR","KLM"];
      function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
      function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
      function makeCallsign(){ return `${pick(FLIGHT_PREFIX)}${rand(100,999)}`; }

      const ATIS_LIBRARY = [
        { kind: "clouds", make: () => `Scattered clouds at ${rand(2000, 16000)} feet` },
        { kind: "wind", make: () => `Wind ${rand(0,360)} degrees, ${rand(4,30)} knots at point ${pick(POINT_KEYS)}` },
        { kind: "rain", make: () => `Light rain at point ${pick(POINT_KEYS)}` },
        { kind: "fogXY", make: () => `Fog between point ${pick(POINT_KEYS)} and point ${pick(POINT_KEYS)}` },
        { kind: "qnh", make: () => `QNH ${rand(980,1035)} hPa at point ${pick(POINT_KEYS)} and FL ${pick([50,100,200,300,400,450])}` },
        { kind: "temp", make: () => `Temperature ${rand(-30,35)} °C at FL ${pick([50,100,200,300,400,450])}, dew point ${rand(-40,20)} °C` },
        { kind: "miljet", make: () => `Fighter jet near point ${pick(POINT_KEYS)} at FL ${pick([80,120,180,250,350,420])}` },
        { kind: "volcano", make: () => `Volcanic eruption near point ${pick(POINT_KEYS)}` },
        { kind: "runway", make: () => `Landing runway at point ${pick(POINT_KEYS)} is ${rand(1,36)} ${pick(["left","right","center"])}` },
        { kind: "vor", make: () => `VOR at point ${pick(POINT_KEYS)} out of service` },
        { kind: "trlvl", make: () => `Point ${pick(POINT_KEYS)}, transition level ${pick([50,60,70])}` },
        { kind: "time", make: () => `Time of message creation is ${rand(0,23).toString().padStart(2,"0")}${rand(0,59).toString().padStart(2,"0")}Z` },
        { kind: "priority", make: () => `Flight ${makeCallsign()} has priority` },
      ];

      function parseCriteria(text){
        const crit = { altitudeFL: null, waypoint: null, flight: null };
        const flm = text.match(/FL\s?(\d{2,3})/i);
        if (flm) crit.altitudeFL = parseInt(flm[1],10);
        const pm = text.match(/point\s([A-Z])/i);
        if (pm) crit.waypoint = pm[1].toUpperCase();
        const fm = text.match(/Flight\s([A-Z]{2,3}\d{3})/i);
        if (fm) crit.flight = fm[1].toUpperCase();
        return crit;
      }
      function isAtisRelevant(text, liveFlights){
        const crit = parseCriteria(text);
        const checks = [];
        if (crit.altitudeFL !== null){ checks.push(crit.altitudeFL >= 100 && crit.altitudeFL <= 400); }
        if (crit.waypoint){ checks.push(Boolean(WAYPOINTS[crit.waypoint])); }
        if (crit.flight){ checks.push(liveFlights.some(f=>f.callsign === crit.flight)); }
        if (checks.length === 0) return false;
        return checks.every(Boolean);
      }

      // Aircraft model ------------------------------------------------------------
      function newAircraftFromLane(lane){
        const { from, to } = lane;
        const posFrom = WAYPOINTS[from];
        const posTo = WAYPOINTS[to];
        const hdg = vectorToHeading(posTo.x - posFrom.x, posTo.y - posFrom.y);
        const v = headingToVector(hdg);
        const start = { x: posFrom.x - v.x * 1.0, y: posFrom.y - v.y * 1.0 };
        const exits = POINT_KEYS.filter((p)=>p!==from);
        const exit = pick(exits);
        const alt = pick([100,200,300,400]);
        const spd = pick([220,240,260,280,300]);
        return {
          id: uid(),
          callsign: makeCallsign(),
          pos: start,
          hdg,
          targetHdg: hdg,
          speed: spd,
          fl: alt * 1.0,
          targetFL: alt * 1.0,
          reqExit: exit,
          reqExitFL: pick([100,200,300,400]),
          conflictWith: new Set(),
          conflictSince: null,
          removed: false,
          reachedExit: false,
          color: "green",
          tagOffset: { x: 12, y: -24 }, // label offset (px) draggable
        };
      }

      // Main ----------------------------------------------------------------------
      function RadarControlTest(){
        const [flights, setFlights] = useState([]);
        const [selectedId, setSelectedId] = useState(null);
        const [atis, setAtis] = useState({ text: "", open: false, since: 0 });
        const [score, setScore] = useState({ nav:0, control:0, audio:0, collisions:0 });
        const [gameStarted, setGameStarted] = useState(false);
        const [minutes, setMinutes] = useState(5);
        const [endTime, setEndTime] = useState(null);
        const [paused, setPaused] = useState(false);

        // Drag state for tags
        const [drag, setDrag] = useState(null); // {id, startX, startY, origOffset}
        const svgRef = useRef(null);
        const size = { w: 96*NM_TO_PX, h: 68*NM_TO_PX };

        useEffect(()=>{
          const timer = setInterval(()=>{
            if (!gameStarted || paused) return;
            const now = Date.now();
            if (endTime && now >= endTime){
              setGameStarted(false);
              return;
            }
            setFlights(prev=>tick(prev));
            setAtis(a=>{
              if (!a.open || Date.now() - a.since < 12000) return a;
              return { text: pick(ATIS_LIBRARY).make(), open: true, since: Date.now() };
            });
          }, TICK_MS);
          return ()=>clearInterval(timer);
        },[gameStarted, paused, endTime]);

        // Pointer handlers for dragging tags
        function getSvgXY(e){
          const rect = svgRef.current.getBoundingClientRect();
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        function onTagPointerDown(e, id){
          e.preventDefault();
          setSelectedId(id);
          const pt = getSvgXY(e);
          const f = flights.find(fl=>fl.id===id);
          if (!f) return;
          setDrag({ id, startX: pt.x, startY: pt.y, origOffset: {...f.tagOffset} });
          // capture pointer moves globally
          window.addEventListener("pointermove", onPointerMove);
          window.addEventListener("pointerup", onPointerUp);
        }
        function onPointerMove(e){
          setDrag((d)=>{
            if (!d) return d;
            const pt = getSvgXY(e);
            const dx = pt.x - d.startX;
            const dy = pt.y - d.startY;
            setFlights(prev=>prev.map(f=>{
              if (f.id!==d.id) return f;
              // constrain inside board
              const p = nm2px(f.pos);
              const w = 170, h = 58;
              let newX = d.origOffset.x + dx;
              let newY = d.origOffset.y + dy;
              // clamp so rect stays in bounds
              newX = clamp(newX, -p.x, size.w - p.x - w);
              newY = clamp(newY, -p.y, size.h - p.y - h);
              return { ...f, tagOffset: { x: newX, y: newY } };
            }));
            return d;
          });
        }
        function onPointerUp(){
          window.removeEventListener("pointermove", onPointerMove);
          window.removeEventListener("pointerup", onPointerUp);
          setDrag(null);
        }

        function tick(prev){
          const now = Date.now();
          const hdgStep = HEADING_DEG_PER_SEC * (TICK_MS/1000);
          const flStep = FL_RATE_PER_SEC * (TICK_MS/1000);
          let next = prev.map(f=> ({...f}));

          next.forEach((f)=>{
            // progressive heading toward targetHdg
            if (f.targetHdg != null){
              let diff = ((f.targetHdg - f.hdg + 540) % 360) - 180;
              if (Math.abs(diff) <= hdgStep){ f.hdg = ((f.targetHdg%360)+360)%360; }
              else { f.hdg = ((f.hdg + Math.sign(diff)*hdgStep)%360 + 360)%360; }
            }
            // progressive altitude toward targetFL
            if (f.targetFL != null){
              const diffFL = f.targetFL - f.fl;
              if (Math.abs(diffFL) <= flStep){ f.fl = f.targetFL; }
              else { f.fl = f.fl + Math.sign(diffFL) * flStep; }
            }

            // movement
            const v = headingToVector(f.hdg);
            const nmPerMin = f.speed / 60;
            const nmPerTick = nmPerMin * (TICK_MS/60000);
            f.pos.x += v.x * nmPerTick;
            f.pos.y += v.y * nmPerTick;

            // corridor color
            const minDist = AIRWAYS.reduce((acc,[p,q])=>{
              const d = pointLineDistanceNM(f.pos, WAYPOINTS[p], WAYPOINTS[q]);
              return Math.min(acc,d);
            }, Infinity);
            f.color = minDist > CORRIDOR_HALF_WIDTH_NM ? "orange" : "green";

            // exit
            const reqExit = WAYPOINTS[f.reqExit];
            if (reqExit && distNM(f.pos, reqExit) < 0.8 && !f.reachedExit){
              f.reachedExit = true;
              if (Math.round(f.fl) === f.reqExitFL){ setScore(s=>({...s, nav: s.nav + 10})); }
              f.removed = true;
            }
          });

          // conflicts (rounded FL)
          for (let i=0;i<next.length;i++){
            for (let j=i+1;j<next.length;j++){
              const a = next[i], b = next[j];
              if (a.removed || b.removed) continue;
              const sameFL = Math.round(a.fl) === Math.round(b.fl);
              const d = distNM(a.pos,b.pos);
              const inConflict = sameFL && d <= 2;
              if (inConflict){
                a.conflictWith.add(b.id); b.conflictWith.add(a.id);
                if (!a.conflictSince) a.conflictSince = now;
                if (!b.conflictSince) b.conflictSince = now;
              } else {
                a.conflictWith.delete(b.id); b.conflictWith.delete(a.id);
                if (a.conflictWith.size===0) a.conflictSince = null;
                if (b.conflictWith.size===0) b.conflictSince = null;
              }
              if (inConflict){
                const started = Math.min(a.conflictSince||now, b.conflictSince||now);
                if (now - started > 5000){
                  a.removed = true; b.removed = true;
                  setScore(s=>({...s, collisions: s.collisions+1, control: Math.max(0, s.control-10)}));
                }
              }
            }
          }

          // keep population; new ones from lanes
          let kept = next.filter(f=>!f.removed);
          const desired = 7;
          while (kept.length < desired){ kept.push(newAircraftFromLane(pick(ENTRY_LANES))); }
          return kept;
        }

        const selected = flights.find(f=>f.id===selectedId) || null;

        // Commands -----------------------------------------------------------------
        function applyConfirm(){
          if (!selected) return;
          setFlights(prev=>prev.map(f=>{
            if (f.id!==selected.id) return f;
            const nf = {...f};
            if (nf.pendingHdg != null){ nf.targetHdg = ((nf.pendingHdg%360)+360)%360; nf.pendingHdg = null; }
            if (nf.pendingFL != null){ nf.targetFL = clamp(nf.pendingFL, 50, 450); nf.pendingFL = null; }
            return nf;
          }));
        }
        function adjustHdg(delta){
          if (!selected) return;
          setFlights(prev=>prev.map(f=> f.id===selected.id ? {...f, pendingHdg: ((f.pendingHdg ?? f.targetHdg ?? f.hdg)+delta)} : f));
        }
        function adjustFL(delta){
          if (!selected) return;
          setFlights(prev=>prev.map(f=> f.id===selected.id ? {...f, pendingFL: (f.pendingFL ?? f.targetFL ?? f.fl) + delta} : f));
        }

        function handleAtis(answer){
          const relevant = isAtisRelevant(atis.text, flights);
          const correct = (answer === (relevant ? "relevant" : "irrelevant"));
          setScore(s=>({...s, audio: s.audio + (correct?5:-3)}));
          setAtis({ text: pick(ATIS_LIBRARY).make(), open: true, since: Date.now() });
        }

        function startGame(){
          const initial = Array.from({length: 7}, ()=> newAircraftFromLane(pick(ENTRY_LANES)));
          setFlights(initial);
          setSelectedId(null);
          setScore({ nav:0, control:0, audio:0, collisions:0 });
          const now = Date.now();
          setEndTime(now + minutes*60*1000);
          setAtis({ text: pick(ATIS_LIBRARY).make(), open: true, since: now });
          setPaused(false);
          setGameStarted(true);
        }

        // HUD
        const remainingMs = endTime ? Math.max(0, endTime - Date.now()) : 0;
        const mm = String(Math.floor(remainingMs/60000)).padStart(2,"0");
        const ss = String(Math.floor((remainingMs%60000)/1000)).padStart(2,"0");

        // helpers
        function nm2px({x,y}){ return { x: x*NM_TO_PX, y: y*NM_TO_PX }; }
        const needleDeg = selected ? (selected.pendingHdg ?? selected.targetHdg ?? selected.hdg) : 0;
        const needleStyle = { height: "54px", transform: "translate(-50%, -100%) rotate(" + needleDeg + "deg)" };

        return (
          <div className="w-full h-full p-4 grid grid-cols-12 gap-4">
            {/* HUD */}
            {gameStarted && (
              <div className="fixed top-3 right-4 z-20 flex items-center gap-3">
                <div className="px-3 py-1 rounded bg-black/70 text-white font-mono">⏳ {mm}:{ss}</div>
                <button className="px-2 py-1 rounded bg-slate-700 text-white" onClick={()=>setPaused(p=>!p)}>{paused? "Resume":"Pause"}</button>
              </div>
            )}

            {/* Radar canvas */}
            <div className="col-span-12 lg:col-span-8">
              <div className="relative bg-sky-100 rounded-2xl shadow-inner overflow-hidden" style={{width:size.w, height:size.h}}>
                <svg ref={svgRef} width={size.w} height={size.h} className="absolute inset-0">
                  {/* Airways */}
                  {AIRWAYS.map(([p,q],i)=>{
                    const a = nm2px(WAYPOINTS[p]);
                    const b = nm2px(WAYPOINTS[q]);
                    return (
                      <g key={i}>
                        <line x1={a.x} y1={a.y} x2={b.x} y2={b.y} stroke="#cbd5e1" strokeWidth={10} strokeLinecap="round" />
                        <line x1={a.x} y1={a.y} x2={b.x} y2={b.y} stroke="#94a3b8" strokeWidth={2} strokeDasharray="6 6" />
                      </g>
                    );
                  })}
                  {/* Waypoints */}
                  {Object.entries(WAYPOINTS).map(([k,p])=>{
                    const s = nm2px(p);
                    return (
                      <g key={k}>
                        <circle cx={s.x} cy={s.y} r={7} fill="#fde68a" stroke="#111827"/>
                        <text x={s.x+10} y={s.y-10} fontSize="12" fill="#111827">{k}</text>
                      </g>
                    );
                  })}

                  {/* Flights */}
                  {flights.map((f)=>{
                    const p = nm2px(f.pos);
                    const hdgVec = headingToVector(f.hdg);
                    const w = 170, h = 58;
                    const tagX = p.x + (f.tagOffset?.x ?? 12);
                    const tagY = p.y + (f.tagOffset?.y ?? -24);
                    const flashing = f.conflictWith.size>0 && ((Date.now()/300)|0)%2===0;
                    const color = flashing ? "#ef4444" : (f.color === "orange" ? "#fb923c" : "#22c55e");
                    return (
                      <g key={f.id}>
                        <line x1={p.x} y1={p.y} x2={p.x+hdgVec.x*18} y2={p.y+hdgVec.y*18} stroke="#111827" strokeWidth={2}/>
                        <circle cx={p.x} cy={p.y} r={5} fill={color} stroke="#0f172a" />

                        {/* Draggable info tag */}
                        <g className="cursor-move select-none"
                           onPointerDown={(e)=>onTagPointerDown(e, f.id)}>
                          <rect x={tagX} y={tagY} width={w} height={h} rx={8} fill="#ffffffcc" stroke={selectedId===f.id?"#0ea5e9":"#334155"} />
                          <text x={tagX+6} y={tagY+14} fontSize="12" fill="#111827">{f.callsign}  {f.speed} kn</text>
                          <text x={tagX+6} y={tagY+30} fontSize="12" fill="#111827">HD {String(Math.round(f.hdg)).padStart(3,"0")}°  FL {Math.round(f.fl)}</text>
                          <text x={tagX+6} y={tagY+46} fontSize="12" fill="#111827">Exit {f.reqExit}  Req FL {f.reqExitFL}</text>
                        </g>
                      </g>
                    );
                  })}
                </svg>

                {/* Start overlay */}
                {!gameStarted && (
                  <div className="absolute inset-0 bg-slate-900/80 text-white flex items-center justify-center">
                    <div className="bg-slate-800 rounded-2xl p-6 w-[420px] shadow-xl">
                      <h2 className="text-xl font-semibold">Radar Control Test</h2>
                      <p className="text-sm opacity-80 mt-1">Selecciona la duración de la partida:</p>
                      <div className="mt-4 grid grid-cols-4 gap-2">
                        {[2,5,8,10].map(m => (
                          <button key={m}
                            onClick={()=>setMinutes(m)}
                            className={"py-2 rounded " + (minutes===m ? "bg-sky-500" : "bg-slate-700 hover:bg-slate-600")}>
                            {m} min
                          </button>
                        ))}
                      </div>
                      <div className="mt-4">
                        <button onClick={startGame} className="w-full py-2 rounded bg-emerald-600 hover:bg-emerald-500">Comenzar</button>
                      </div>
                      <p className="text-xs opacity-70 mt-3">Ahora puedes <b>arrastrar</b> las etiquetas para evitar solapes. Cambios de rumbo/FL se aplican progresivamente.</p>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Right-hand control panel */}
            <div className="col-span-12 lg:col-span-4 flex flex-col gap-4">
              <div className="rounded-2xl p-4 bg-slate-800 text-white shadow-xl">
                <div className="flex items-center justify-between">
                  <h2 className="text-lg font-semibold">Control Panel</h2>
                  <span className="text-sm opacity-80">Flights: {flights.length}</span>
                </div>

                {selected ? (
                  <div className="mt-3 grid grid-cols-2 gap-3 items-center">
                    <div className="col-span-2 flex items-center justify-between">
                      <div>
                        <div className="font-mono text-xl">{selected.callsign}</div>
                        <div className="text-xs opacity-80">Exit {selected.reqExit} · Req FL {selected.reqExitFL}</div>
                      </div>
                      <button className="px-2 py-1 rounded bg-slate-600 hover:bg-slate-500" onClick={()=>setSelectedId(null)}>Unselect</button>
                    </div>

                    {/* Heading dial */}
                    <div className="col-span-1 flex flex-col items-center">
                      <div className="w-28 h-28 rounded-full bg-slate-700 relative flex items-center justify-center">
                        <div className="absolute inset-2 rounded-full border border-slate-500"></div>
                        <div className="absolute left-1/2 top-1/2 origin-bottom -translate-x-1/2 -translate-y-full" style={needleStyle}>
                          <div className="w-0 h-0 border-l-4 border-r-4 border-b-8 border-l-transparent border-r-transparent border-b-orange-400"></div>
                        </div>
                        <div className="absolute text-xs bottom-1">HDG {String(Math.round(needleDeg)).padStart(3,'0')}°</div>
                      </div>
                      <div className="mt-2 flex gap-2">
                        <button className="px-3 py-1 rounded bg-sky-600 hover:bg-sky-500" onClick={()=>adjustHdg(-5)}>LEFT</button>
                        <button className="px-3 py-1 rounded bg-sky-600 hover:bg-sky-500" onClick={()=>adjustHdg(5)}>RIGHT</button>
                      </div>
                    </div>

                    {/* Altitude */}
                    <div className="col-span-1 flex flex-col items-center">
                      <div className="text-sm opacity-80">Altitude</div>
                      <div className="text-3xl font-mono">FL {selected.fl.toFixed(1)}</div>
                      {(selected.pendingFL != null || (selected.targetFL != null && Math.round(selected.targetFL) !== Math.round(selected.fl))) && (
                        <div className="text-xs opacity-80 mt-1">
                          Objetivo: FL {Math.round((selected.pendingFL ?? selected.targetFL))}
                        </div>
                      )}
                      <div className="mt-2 flex gap-2">
                        <button className="px-2 py-1 rounded bg-slate-600 hover:bg-slate-500" onClick={()=>adjustFL(-100)}>-</button>
                        <button className="px-2 py-1 rounded bg-slate-600 hover:bg-slate-500" onClick={()=>adjustFL(+100)}>+</button>
                      </div>
                    </div>

                    <div className="col-span-2 mt-2">
                      <button className="w-full py-2 rounded bg-rose-600 hover:bg-rose-500 text-white" onClick={applyConfirm}>CONFIRM</button>
                    </div>
                  </div>
                ) : (
                  <div className="mt-3 text-sm opacity-80">Selecciona un vuelo, ajusta rumbo/nivel y pulsa <b>CONFIRM</b>. También puedes <b>arrastrar</b> las etiquetas en el radar.</div>
                )}
              </div>

              {/* ATIS / Audio task */}
              <div className="rounded-2xl p-4 bg-slate-900 text-white shadow-xl">
                <div className="flex items-center justify-between mb-2">
                  <h3 className="font-semibold">Radio Message</h3>
                  <div className="text-xs opacity-70">You have ~12s per call</div>
                </div>
                <div className="bg-slate-800 rounded p-3 min-h-[64px] flex items-center">{atis.text}</div>
                <div className="mt-3 grid grid-cols-2 gap-3">
                  <button className="py-2 rounded bg-emerald-600 hover:bg-emerald-500" onClick={()=>handleAtis("relevant")}>Relevant</button>
                  <button className="py-2 rounded bg-amber-600 hover:bg-amber-500" onClick={()=>handleAtis("irrelevant")}>Irrelevant</button>
                </div>
                <p className="text-xs opacity-70 mt-2">Criterios de relevancia: FL 100–400, waypoint del sector y/o vuelo activo — si aparecen combinados, todos deben ser relevantes.</p>
              </div>

              {/* Score / status */}
              <div className="rounded-2xl p-4 bg-white shadow">
                <h4 className="font-semibold mb-2">Rendimiento</h4>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div className="p-2 rounded bg-slate-100">Navigation: <b>{score.nav}</b></div>
                  <div className="p-2 rounded bg-slate-100">Control: <b>{score.control}</b></div>
                  <div className="p-2 rounded bg-slate-100">Audio: <b>{score.audio}</b></div>
                  <div className="p-2 rounded bg-slate-100">Collisions: <b>{score.collisions}</b></div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("app"));
      root.render(<RadarControlTest />);
    </script>
  </body>
</html>
